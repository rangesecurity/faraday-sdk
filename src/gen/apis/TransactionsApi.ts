/* tslint:disable */
/* eslint-disable */
/**
 * Faraday API
 *  The **Faraday API** provides secure, compliant infrastructure for stablecoin transactions, identity verification, and transaction monitoring across multiple blockchains.  ### Key Features - **Swap Routing** — Discover optimal swap paths for stablecoin transfers, including cross-chain routes. - **IVMS101 Person Records** — Create, query, and manage structured person data for FATF Travel Rule compliance. - **Transaction Submission and Monitoring** — Submit and track stablecoin transactions. - **Reporting** — View historical transaction reports including associated IVMS101 records.  ### Authentication Most requests require an API key (Bearer token).  Generate and manage API keys by signing in to: - Production: https://app.range.org/ - Staging: https://stage.range.org/  API Keys can be found under the APIs section. A free monthly credit allowance is available, with more credits available to paid plans.  Include this header with every authenticated Faraday request:  ``` Authorization: Bearer <your_token> ```  ### Base URLs - Production: `https://api.faraday.range.org` - Staging: `https://faraday.api.rase.live` - Local Development: `http://0.0.0.0:3000`  ### Example Request ```bash curl -X GET \'https://api.faraday.range.org/v1/persons\'   --header \'Authorization: Bearer <your_token>\' ```         
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: faraday@range.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ErrorResponse,
  Network,
  QuoteWithRisk,
  QuotesWithRisk,
  SubmitTransactionRequest,
  SubmitTransactionResponse,
  TransactionReport,
} from '../models/index';
import {
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    NetworkFromJSON,
    NetworkToJSON,
    QuoteWithRiskFromJSON,
    QuoteWithRiskToJSON,
    QuotesWithRiskFromJSON,
    QuotesWithRiskToJSON,
    SubmitTransactionRequestFromJSON,
    SubmitTransactionRequestToJSON,
    SubmitTransactionResponseFromJSON,
    SubmitTransactionResponseToJSON,
    TransactionReportFromJSON,
    TransactionReportToJSON,
} from '../models/index';

export interface GetQuoteRequest {
    fromChain: Network;
    fromAddress: string;
    fromAsset: string;
    toChain: Network;
    toAsset: string;
    amount: string;
    slippageBps: number;
    toAddress: string;
    travelRuleCompliant?: boolean;
}

export interface GetQuotesRequest {
    fromChain: Network;
    fromAddress: string;
    fromAsset: string;
    toChain: Network;
    toAsset: string;
    amount: string;
    slippageBps: number;
    toAddress: string;
    travelRuleCompliant?: boolean;
}

export interface GetTransactionByHashRequest {
    id: string;
}

export interface PostTransactionRequest {
    submitTransactionRequest: SubmitTransactionRequest;
}

/**
 * 
 */
export class TransactionsApi extends runtime.BaseAPI {

    /**
     *  Retrieves a cross-chain transfer or swap quote from multiple aggregators:  - **Skip Go** - **Lifi** - **DeBridge**  The service selects the **best available route** based on price and execution parameters.  Along with the quote, the response includes: - An **unsigned transaction** ready for signing. - A **risk report** generated by Range\'s Machine Learning models, designed to help **mitigate fraud and compliance risks**.  This endpoint offers **optimal routing and embedded risk assessment**.  If travel_rule_compliant is true, the system will verify that both the sender and recipient have valid IVMS101 person records stored. If these records are missing or invalid, the request will fail with a validation error (422). 
     * Get the best available quote for a stablecoin transfer
     */
    async getQuoteRaw(requestParameters: GetQuoteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuoteWithRisk>> {
        if (requestParameters['fromChain'] == null) {
            throw new runtime.RequiredError(
                'fromChain',
                'Required parameter "fromChain" was null or undefined when calling getQuote().'
            );
        }

        if (requestParameters['fromAddress'] == null) {
            throw new runtime.RequiredError(
                'fromAddress',
                'Required parameter "fromAddress" was null or undefined when calling getQuote().'
            );
        }

        if (requestParameters['fromAsset'] == null) {
            throw new runtime.RequiredError(
                'fromAsset',
                'Required parameter "fromAsset" was null or undefined when calling getQuote().'
            );
        }

        if (requestParameters['toChain'] == null) {
            throw new runtime.RequiredError(
                'toChain',
                'Required parameter "toChain" was null or undefined when calling getQuote().'
            );
        }

        if (requestParameters['toAsset'] == null) {
            throw new runtime.RequiredError(
                'toAsset',
                'Required parameter "toAsset" was null or undefined when calling getQuote().'
            );
        }

        if (requestParameters['amount'] == null) {
            throw new runtime.RequiredError(
                'amount',
                'Required parameter "amount" was null or undefined when calling getQuote().'
            );
        }

        if (requestParameters['slippageBps'] == null) {
            throw new runtime.RequiredError(
                'slippageBps',
                'Required parameter "slippageBps" was null or undefined when calling getQuote().'
            );
        }

        if (requestParameters['toAddress'] == null) {
            throw new runtime.RequiredError(
                'toAddress',
                'Required parameter "toAddress" was null or undefined when calling getQuote().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fromChain'] != null) {
            queryParameters['from_chain'] = requestParameters['fromChain'];
        }

        if (requestParameters['fromAddress'] != null) {
            queryParameters['from_address'] = requestParameters['fromAddress'];
        }

        if (requestParameters['fromAsset'] != null) {
            queryParameters['from_asset'] = requestParameters['fromAsset'];
        }

        if (requestParameters['toChain'] != null) {
            queryParameters['to_chain'] = requestParameters['toChain'];
        }

        if (requestParameters['toAsset'] != null) {
            queryParameters['to_asset'] = requestParameters['toAsset'];
        }

        if (requestParameters['amount'] != null) {
            queryParameters['amount'] = requestParameters['amount'];
        }

        if (requestParameters['slippageBps'] != null) {
            queryParameters['slippage_bps'] = requestParameters['slippageBps'];
        }

        if (requestParameters['toAddress'] != null) {
            queryParameters['to_address'] = requestParameters['toAddress'];
        }

        if (requestParameters['travelRuleCompliant'] != null) {
            queryParameters['travel_rule_compliant'] = requestParameters['travelRuleCompliant'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/transactions/quote`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuoteWithRiskFromJSON(jsonValue));
    }

    /**
     *  Retrieves a cross-chain transfer or swap quote from multiple aggregators:  - **Skip Go** - **Lifi** - **DeBridge**  The service selects the **best available route** based on price and execution parameters.  Along with the quote, the response includes: - An **unsigned transaction** ready for signing. - A **risk report** generated by Range\'s Machine Learning models, designed to help **mitigate fraud and compliance risks**.  This endpoint offers **optimal routing and embedded risk assessment**.  If travel_rule_compliant is true, the system will verify that both the sender and recipient have valid IVMS101 person records stored. If these records are missing or invalid, the request will fail with a validation error (422). 
     * Get the best available quote for a stablecoin transfer
     */
    async getQuote(requestParameters: GetQuoteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuoteWithRisk> {
        const response = await this.getQuoteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  Fetches **all viable quotes** from supported aggregators (Skip, LiFi, deBridge, etc.) in parallel and returns them **together** with a **single ML risk assessment** for the payment.  - Uses the same address/amount inputs for all providers. - Risk assessment is computed once (same inputs) and attached to the response. - If `travel_rule_compliant` is true, verifies IVMS101 records for sender & recipient before quoting. 
     * Get all available quotes for a stablecoin transfer
     */
    async getQuotesRaw(requestParameters: GetQuotesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuotesWithRisk>> {
        if (requestParameters['fromChain'] == null) {
            throw new runtime.RequiredError(
                'fromChain',
                'Required parameter "fromChain" was null or undefined when calling getQuotes().'
            );
        }

        if (requestParameters['fromAddress'] == null) {
            throw new runtime.RequiredError(
                'fromAddress',
                'Required parameter "fromAddress" was null or undefined when calling getQuotes().'
            );
        }

        if (requestParameters['fromAsset'] == null) {
            throw new runtime.RequiredError(
                'fromAsset',
                'Required parameter "fromAsset" was null or undefined when calling getQuotes().'
            );
        }

        if (requestParameters['toChain'] == null) {
            throw new runtime.RequiredError(
                'toChain',
                'Required parameter "toChain" was null or undefined when calling getQuotes().'
            );
        }

        if (requestParameters['toAsset'] == null) {
            throw new runtime.RequiredError(
                'toAsset',
                'Required parameter "toAsset" was null or undefined when calling getQuotes().'
            );
        }

        if (requestParameters['amount'] == null) {
            throw new runtime.RequiredError(
                'amount',
                'Required parameter "amount" was null or undefined when calling getQuotes().'
            );
        }

        if (requestParameters['slippageBps'] == null) {
            throw new runtime.RequiredError(
                'slippageBps',
                'Required parameter "slippageBps" was null or undefined when calling getQuotes().'
            );
        }

        if (requestParameters['toAddress'] == null) {
            throw new runtime.RequiredError(
                'toAddress',
                'Required parameter "toAddress" was null or undefined when calling getQuotes().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fromChain'] != null) {
            queryParameters['from_chain'] = requestParameters['fromChain'];
        }

        if (requestParameters['fromAddress'] != null) {
            queryParameters['from_address'] = requestParameters['fromAddress'];
        }

        if (requestParameters['fromAsset'] != null) {
            queryParameters['from_asset'] = requestParameters['fromAsset'];
        }

        if (requestParameters['toChain'] != null) {
            queryParameters['to_chain'] = requestParameters['toChain'];
        }

        if (requestParameters['toAsset'] != null) {
            queryParameters['to_asset'] = requestParameters['toAsset'];
        }

        if (requestParameters['amount'] != null) {
            queryParameters['amount'] = requestParameters['amount'];
        }

        if (requestParameters['slippageBps'] != null) {
            queryParameters['slippage_bps'] = requestParameters['slippageBps'];
        }

        if (requestParameters['toAddress'] != null) {
            queryParameters['to_address'] = requestParameters['toAddress'];
        }

        if (requestParameters['travelRuleCompliant'] != null) {
            queryParameters['travel_rule_compliant'] = requestParameters['travelRuleCompliant'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/transactions/quotes`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuotesWithRiskFromJSON(jsonValue));
    }

    /**
     *  Fetches **all viable quotes** from supported aggregators (Skip, LiFi, deBridge, etc.) in parallel and returns them **together** with a **single ML risk assessment** for the payment.  - Uses the same address/amount inputs for all providers. - Risk assessment is computed once (same inputs) and attached to the response. - If `travel_rule_compliant` is true, verifies IVMS101 records for sender & recipient before quoting. 
     * Get all available quotes for a stablecoin transfer
     */
    async getQuotes(requestParameters: GetQuotesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuotesWithRisk> {
        const response = await this.getQuotesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  Returns a single processed transaction by its unique transaction hash.  ### Response - Includes transaction metadata such as:   - Transaction hash   - Network (e.g., Solana, Ethereum)   - Amount (in base units)   - Travel rule compliance status   - Timestamps   - Full IVMS101 sender and recipient records if available  ### Notes - If IVMS101 records are missing, the `sender` or `recipient` fields will be `null`. - Use this endpoint to audit a transaction or verify travel rule compliance.  ### Errors - Returns `404` if the transaction hash is not found. - Returns `500` if an internal server or database error occurs. 
     * Get a transaction
     */
    async getTransactionByHashRaw(requestParameters: GetTransactionByHashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionReport>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getTransactionByHash().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/transactions/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionReportFromJSON(jsonValue));
    }

    /**
     *  Returns a single processed transaction by its unique transaction hash.  ### Response - Includes transaction metadata such as:   - Transaction hash   - Network (e.g., Solana, Ethereum)   - Amount (in base units)   - Travel rule compliance status   - Timestamps   - Full IVMS101 sender and recipient records if available  ### Notes - If IVMS101 records are missing, the `sender` or `recipient` fields will be `null`. - Use this endpoint to audit a transaction or verify travel rule compliance.  ### Errors - Returns `404` if the transaction hash is not found. - Returns `500` if an internal server or database error occurs. 
     * Get a transaction
     */
    async getTransactionByHash(requestParameters: GetTransactionByHashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionReport> {
        const response = await this.getTransactionByHashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  Returns a list of processed transactions with associated sender and recipient IVMS101 records, if available.  ### Response Each transaction includes: - Transaction hash - Amount (in base units) - Travel rule compliance flag - Timestamps - Full sender and recipient records if present  ### Notes - Transactions are returned in descending order of creation (most recent first). - If IVMS101 records are not found, `sender` or `recipient` fields may be null.  ### Errors - Returns 500 in the event of an unexpected database or internal failure. 
     * List transactions for the authenticated user
     */
    async getTransactionsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TransactionReport>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/transactions`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TransactionReportFromJSON));
    }

    /**
     *  Returns a list of processed transactions with associated sender and recipient IVMS101 records, if available.  ### Response Each transaction includes: - Transaction hash - Amount (in base units) - Travel rule compliance flag - Timestamps - Full sender and recipient records if present  ### Notes - Transactions are returned in descending order of creation (most recent first). - If IVMS101 records are not found, `sender` or `recipient` fields may be null.  ### Errors - Returns 500 in the event of an unexpected database or internal failure. 
     * List transactions for the authenticated user
     */
    async getTransactions(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TransactionReport>> {
        const response = await this.getTransactionsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Submit a signed transaction
     */
    async postTransactionRaw(requestParameters: PostTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubmitTransactionResponse>> {
        if (requestParameters['submitTransactionRequest'] == null) {
            throw new runtime.RequiredError(
                'submitTransactionRequest',
                'Required parameter "submitTransactionRequest" was null or undefined when calling postTransaction().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/transactions`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SubmitTransactionRequestToJSON(requestParameters['submitTransactionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubmitTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Submit a signed transaction
     */
    async postTransaction(requestParameters: PostTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubmitTransactionResponse> {
        const response = await this.postTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
