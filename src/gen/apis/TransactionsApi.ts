/* tslint:disable */
/* eslint-disable */
/**
 * Faraday API
 *  The **Faraday API** provides secure, compliant infrastructure for stablecoin transactions, identity verification, and transaction monitoring across multiple blockchains.  ### Key Features - **Swap Routing** — Discover optimal swap paths for stablecoin transfers, including cross-chain routes. - **IVMS101 Person Records** — Create, query, and manage structured person data for FATF Travel Rule compliance. - **Transaction Submission and Monitoring** — Submit and track stablecoin transactions. - **Reporting** — View historical transaction reports including associated IVMS101 records.  ### Authentication Most requests require an API key (Bearer token).  Generate and manage API keys by signing in to: - Production: https://app.range.org/ - Staging: https://stage.range.org/  API Keys can be found under the APIs section. A free monthly credit allowance is available, with more credits available to paid plans.  Include this header with every authenticated Faraday request:  ``` Authorization: Bearer <your_token> ```  ### Base URLs - Production: `https://api.faraday.range.org` - Staging: `https://faraday.api.rase.live` - Local Development: `http://0.0.0.0:3000`  ### Example Request ```bash curl -X GET \'https://api.faraday.range.org/v1/persons\'   --header \'Authorization: Bearer <your_token>\' ```         
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: faraday@range.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ErrorResponse,
  Network,
  QuoteWithRisk,
  QuotesWithRisk,
  SubmitTransactionRequest,
  SubmitTransactionResponse,
  TransactionReport,
  TxStatusResponse,
} from '../models/index';
import {
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    NetworkFromJSON,
    NetworkToJSON,
    QuoteWithRiskFromJSON,
    QuoteWithRiskToJSON,
    QuotesWithRiskFromJSON,
    QuotesWithRiskToJSON,
    SubmitTransactionRequestFromJSON,
    SubmitTransactionRequestToJSON,
    SubmitTransactionResponseFromJSON,
    SubmitTransactionResponseToJSON,
    TransactionReportFromJSON,
    TransactionReportToJSON,
    TxStatusResponseFromJSON,
    TxStatusResponseToJSON,
} from '../models/index';

export interface GetQuoteRequest {
    fromChain: Network;
    fromAddress: string;
    fromAsset: string;
    toChain: Network;
    toAsset: string;
    amount: string;
    slippageBps: number;
    toAddress: string;
    travelRuleCompliant?: boolean;
}

export interface GetQuotesRequest {
    fromChain: Network;
    fromAddress: string;
    fromAsset: string;
    toChain: Network;
    toAsset: string;
    amount: string;
    slippageBps: number;
    toAddress: string;
    travelRuleCompliant?: boolean;
}

export interface GetTransactionByHashRequest {
    txHash: string;
}

export interface PostTransactionRequest {
    submitTransactionRequest: SubmitTransactionRequest;
}

export interface TrackTransactionRequest {
    txHash: string;
    quoteId?: string;
}

/**
 * 
 */
export class TransactionsApi extends runtime.BaseAPI {

    /**
     *  Retrieves a cross-chain transfer or swap quote from multiple quote providers:  - **Skip Go** - **Lifi** - **Squid** - **DeBridge** - **Switchain**  The service selects the **best available route** based on price and execution parameters.  Along with the quote, the response includes: - An **unsigned transaction** ready for signing. - A **risk report** generated by Range\'s Machine Learning models, designed to help **mitigate fraud and compliance risks**.  This endpoint offers **optimal routing and embedded risk assessment**.  If travel_rule_compliant is true, the system will verify that both the sender and recipient have valid IVMS101 person records stored. If these records are missing or invalid, the request will fail with a validation error (422). 
     * Get the best available quote for a stablecoin transfer
     */
    async getQuoteRaw(requestParameters: GetQuoteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuoteWithRisk>> {
        if (requestParameters['fromChain'] == null) {
            throw new runtime.RequiredError(
                'fromChain',
                'Required parameter "fromChain" was null or undefined when calling getQuote().'
            );
        }

        if (requestParameters['fromAddress'] == null) {
            throw new runtime.RequiredError(
                'fromAddress',
                'Required parameter "fromAddress" was null or undefined when calling getQuote().'
            );
        }

        if (requestParameters['fromAsset'] == null) {
            throw new runtime.RequiredError(
                'fromAsset',
                'Required parameter "fromAsset" was null or undefined when calling getQuote().'
            );
        }

        if (requestParameters['toChain'] == null) {
            throw new runtime.RequiredError(
                'toChain',
                'Required parameter "toChain" was null or undefined when calling getQuote().'
            );
        }

        if (requestParameters['toAsset'] == null) {
            throw new runtime.RequiredError(
                'toAsset',
                'Required parameter "toAsset" was null or undefined when calling getQuote().'
            );
        }

        if (requestParameters['amount'] == null) {
            throw new runtime.RequiredError(
                'amount',
                'Required parameter "amount" was null or undefined when calling getQuote().'
            );
        }

        if (requestParameters['slippageBps'] == null) {
            throw new runtime.RequiredError(
                'slippageBps',
                'Required parameter "slippageBps" was null or undefined when calling getQuote().'
            );
        }

        if (requestParameters['toAddress'] == null) {
            throw new runtime.RequiredError(
                'toAddress',
                'Required parameter "toAddress" was null or undefined when calling getQuote().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fromChain'] != null) {
            queryParameters['from_chain'] = requestParameters['fromChain'];
        }

        if (requestParameters['fromAddress'] != null) {
            queryParameters['from_address'] = requestParameters['fromAddress'];
        }

        if (requestParameters['fromAsset'] != null) {
            queryParameters['from_asset'] = requestParameters['fromAsset'];
        }

        if (requestParameters['toChain'] != null) {
            queryParameters['to_chain'] = requestParameters['toChain'];
        }

        if (requestParameters['toAsset'] != null) {
            queryParameters['to_asset'] = requestParameters['toAsset'];
        }

        if (requestParameters['amount'] != null) {
            queryParameters['amount'] = requestParameters['amount'];
        }

        if (requestParameters['slippageBps'] != null) {
            queryParameters['slippage_bps'] = requestParameters['slippageBps'];
        }

        if (requestParameters['toAddress'] != null) {
            queryParameters['to_address'] = requestParameters['toAddress'];
        }

        if (requestParameters['travelRuleCompliant'] != null) {
            queryParameters['travel_rule_compliant'] = requestParameters['travelRuleCompliant'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/transactions/quote`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuoteWithRiskFromJSON(jsonValue));
    }

    /**
     *  Retrieves a cross-chain transfer or swap quote from multiple quote providers:  - **Skip Go** - **Lifi** - **Squid** - **DeBridge** - **Switchain**  The service selects the **best available route** based on price and execution parameters.  Along with the quote, the response includes: - An **unsigned transaction** ready for signing. - A **risk report** generated by Range\'s Machine Learning models, designed to help **mitigate fraud and compliance risks**.  This endpoint offers **optimal routing and embedded risk assessment**.  If travel_rule_compliant is true, the system will verify that both the sender and recipient have valid IVMS101 person records stored. If these records are missing or invalid, the request will fail with a validation error (422). 
     * Get the best available quote for a stablecoin transfer
     */
    async getQuote(requestParameters: GetQuoteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuoteWithRisk> {
        const response = await this.getQuoteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  Fetches **all viable quotes** from supported quote providers (Skip, LiFi, deBridge, etc.) in parallel and returns them **together** with a **single ML risk assessment** for the payment.  - Uses the same address/amount inputs for all providers. - Risk assessment is computed once (same inputs) and attached to the response. - If `travel_rule_compliant` is true, verifies IVMS101 records for sender & recipient before quoting. 
     * Get all available quotes for a stablecoin transfer
     */
    async getQuotesRaw(requestParameters: GetQuotesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuotesWithRisk>> {
        if (requestParameters['fromChain'] == null) {
            throw new runtime.RequiredError(
                'fromChain',
                'Required parameter "fromChain" was null or undefined when calling getQuotes().'
            );
        }

        if (requestParameters['fromAddress'] == null) {
            throw new runtime.RequiredError(
                'fromAddress',
                'Required parameter "fromAddress" was null or undefined when calling getQuotes().'
            );
        }

        if (requestParameters['fromAsset'] == null) {
            throw new runtime.RequiredError(
                'fromAsset',
                'Required parameter "fromAsset" was null or undefined when calling getQuotes().'
            );
        }

        if (requestParameters['toChain'] == null) {
            throw new runtime.RequiredError(
                'toChain',
                'Required parameter "toChain" was null or undefined when calling getQuotes().'
            );
        }

        if (requestParameters['toAsset'] == null) {
            throw new runtime.RequiredError(
                'toAsset',
                'Required parameter "toAsset" was null or undefined when calling getQuotes().'
            );
        }

        if (requestParameters['amount'] == null) {
            throw new runtime.RequiredError(
                'amount',
                'Required parameter "amount" was null or undefined when calling getQuotes().'
            );
        }

        if (requestParameters['slippageBps'] == null) {
            throw new runtime.RequiredError(
                'slippageBps',
                'Required parameter "slippageBps" was null or undefined when calling getQuotes().'
            );
        }

        if (requestParameters['toAddress'] == null) {
            throw new runtime.RequiredError(
                'toAddress',
                'Required parameter "toAddress" was null or undefined when calling getQuotes().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fromChain'] != null) {
            queryParameters['from_chain'] = requestParameters['fromChain'];
        }

        if (requestParameters['fromAddress'] != null) {
            queryParameters['from_address'] = requestParameters['fromAddress'];
        }

        if (requestParameters['fromAsset'] != null) {
            queryParameters['from_asset'] = requestParameters['fromAsset'];
        }

        if (requestParameters['toChain'] != null) {
            queryParameters['to_chain'] = requestParameters['toChain'];
        }

        if (requestParameters['toAsset'] != null) {
            queryParameters['to_asset'] = requestParameters['toAsset'];
        }

        if (requestParameters['amount'] != null) {
            queryParameters['amount'] = requestParameters['amount'];
        }

        if (requestParameters['slippageBps'] != null) {
            queryParameters['slippage_bps'] = requestParameters['slippageBps'];
        }

        if (requestParameters['toAddress'] != null) {
            queryParameters['to_address'] = requestParameters['toAddress'];
        }

        if (requestParameters['travelRuleCompliant'] != null) {
            queryParameters['travel_rule_compliant'] = requestParameters['travelRuleCompliant'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/transactions/quotes`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuotesWithRiskFromJSON(jsonValue));
    }

    /**
     *  Fetches **all viable quotes** from supported quote providers (Skip, LiFi, deBridge, etc.) in parallel and returns them **together** with a **single ML risk assessment** for the payment.  - Uses the same address/amount inputs for all providers. - Risk assessment is computed once (same inputs) and attached to the response. - If `travel_rule_compliant` is true, verifies IVMS101 records for sender & recipient before quoting. 
     * Get all available quotes for a stablecoin transfer
     */
    async getQuotes(requestParameters: GetQuotesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuotesWithRisk> {
        const response = await this.getQuotesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  Retrieves a single processed transaction by its unique transaction hash.  Note transactions must be submitted via the Faraday API to be available on this endpoint.   ### Response Includes: - Transaction hash - Network (e.g., Solana, Ethereum) - Amount (in base units) - Travel Rule compliance status - Timestamp of creation or observation - Full IVMS101 sender and recipient records, if available  ### Notes - If IVMS101 records are missing, `sender` or `recipient` will be `null`. - Use this endpoint to audit a transaction or verify compliance.  ### Errors - **404 Not Found** – Transaction hash does not exist. - **500 Internal Server Error** – Unexpected database or internal failure. 
     * Get a transaction by hash
     */
    async getTransactionByHashRaw(requestParameters: GetTransactionByHashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionReport>> {
        if (requestParameters['txHash'] == null) {
            throw new runtime.RequiredError(
                'txHash',
                'Required parameter "txHash" was null or undefined when calling getTransactionByHash().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/transactions/{tx_hash}`;
        urlPath = urlPath.replace(`{${"tx_hash"}}`, encodeURIComponent(String(requestParameters['txHash'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionReportFromJSON(jsonValue));
    }

    /**
     *  Retrieves a single processed transaction by its unique transaction hash.  Note transactions must be submitted via the Faraday API to be available on this endpoint.   ### Response Includes: - Transaction hash - Network (e.g., Solana, Ethereum) - Amount (in base units) - Travel Rule compliance status - Timestamp of creation or observation - Full IVMS101 sender and recipient records, if available  ### Notes - If IVMS101 records are missing, `sender` or `recipient` will be `null`. - Use this endpoint to audit a transaction or verify compliance.  ### Errors - **404 Not Found** – Transaction hash does not exist. - **500 Internal Server Error** – Unexpected database or internal failure. 
     * Get a transaction by hash
     */
    async getTransactionByHash(requestParameters: GetTransactionByHashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionReport> {
        const response = await this.getTransactionByHashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  Returns a list of processed transactions with associated sender and recipient IVMS101 records, if available.  ### Response Each transaction includes: - **Transaction hash** - **Amount** (in base units) - **Travel Rule compliance flag** - **Timestamps** - Full **sender** and **recipient** records, if present  ### Notes - Transactions are returned in **descending order of creation** (most recent first). - If IVMS101 records are not found, `sender` or `recipient` fields may be `null`.  ### Errors - **500 Internal Server Error** – Unexpected database or internal failure. 
     * List transactions for the authenticated user
     */
    async getTransactionsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TransactionReport>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/transactions`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TransactionReportFromJSON));
    }

    /**
     *  Returns a list of processed transactions with associated sender and recipient IVMS101 records, if available.  ### Response Each transaction includes: - **Transaction hash** - **Amount** (in base units) - **Travel Rule compliance flag** - **Timestamps** - Full **sender** and **recipient** records, if present  ### Notes - Transactions are returned in **descending order of creation** (most recent first). - If IVMS101 records are not found, `sender` or `recipient` fields may be `null`.  ### Errors - **500 Internal Server Error** – Unexpected database or internal failure. 
     * List transactions for the authenticated user
     */
    async getTransactions(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TransactionReport>> {
        const response = await this.getTransactionsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Submit a signed transaction
     */
    async postTransactionRaw(requestParameters: PostTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubmitTransactionResponse>> {
        if (requestParameters['submitTransactionRequest'] == null) {
            throw new runtime.RequiredError(
                'submitTransactionRequest',
                'Required parameter "submitTransactionRequest" was null or undefined when calling postTransaction().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/transactions`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SubmitTransactionRequestToJSON(requestParameters['submitTransactionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubmitTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Submit a signed transaction
     */
    async postTransaction(requestParameters: PostTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubmitTransactionResponse> {
        const response = await this.postTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  Returns the status of a transaction by hash.    The `status` key of the response provides a status of the transaction which is one of  - submitted - pending - completed - failed - abandoned - unknown  The `raw` key provides the full response from the provider, which may provide additional information including links to block explorers and intermediary transactions. As each provider response is different it is up to clients to parse raw provider responses to use them.   ### Query Parameters Clients that did not submit their transaction via the Faraday API can still use this endpoint by providing:  - **tx_hash** *(required, path)* — The transaction hash on the source chain. - **quote_id** *(optional, query string)* — If the transaction originated from a Faraday quote, include the quote UUID to link to the original quote record.  ### Errors - Returns 404 if the transaction cannot be found. - Returns 500 in the event of an unexpected database or internal failure. 
     * Track a transaction by hash
     */
    async trackTransactionRaw(requestParameters: TrackTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TxStatusResponse>> {
        if (requestParameters['txHash'] == null) {
            throw new runtime.RequiredError(
                'txHash',
                'Required parameter "txHash" was null or undefined when calling trackTransaction().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['quoteId'] != null) {
            queryParameters['quote_id'] = requestParameters['quoteId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/transactions/track/{tx_hash}`;
        urlPath = urlPath.replace(`{${"tx_hash"}}`, encodeURIComponent(String(requestParameters['txHash'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TxStatusResponseFromJSON(jsonValue));
    }

    /**
     *  Returns the status of a transaction by hash.    The `status` key of the response provides a status of the transaction which is one of  - submitted - pending - completed - failed - abandoned - unknown  The `raw` key provides the full response from the provider, which may provide additional information including links to block explorers and intermediary transactions. As each provider response is different it is up to clients to parse raw provider responses to use them.   ### Query Parameters Clients that did not submit their transaction via the Faraday API can still use this endpoint by providing:  - **tx_hash** *(required, path)* — The transaction hash on the source chain. - **quote_id** *(optional, query string)* — If the transaction originated from a Faraday quote, include the quote UUID to link to the original quote record.  ### Errors - Returns 404 if the transaction cannot be found. - Returns 500 in the event of an unexpected database or internal failure. 
     * Track a transaction by hash
     */
    async trackTransaction(requestParameters: TrackTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TxStatusResponse> {
        const response = await this.trackTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
